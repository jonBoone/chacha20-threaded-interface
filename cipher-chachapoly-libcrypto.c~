/*
 * Copyright (c) 2013 Damien Miller <djm@mindrot.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* $OpenBSD: cipher-chachapoly-libcrypto.c,v 1.1 2020/04/03 04:32:21 djm Exp $ */

#include "includes.h"
#ifdef WITH_OPENSSL
#include "openbsd-compat/openssl-compat.h"
#endif

#if defined(HAVE_EVP_CHACHA20) && !defined(HAVE_BROKEN_CHACHA20)

#include <sys/types.h>
#include <stdarg.h> /* needed for log.h */
#include <string.h>
#include <stdio.h>  /* needed for misc.h */

#include <openssl/evp.h>

#include "log.h"
#include "sshbuf.h"
#include "ssherr.h"
#include "cipher-chachapoly.h"

struct chachapoly_ctx {
	EVP_CIPHER_CTX *main_evp, *header_evp;
};

struct chachathread {
	u_char *dest;
	const u_char *src;
	u_int len;
	u_int aadlen;
	u_char *seqbuf;
	struct chachapoly_ctx *ctx;
	int response;
} chachathread;

void *chachapoly_thread_work(void *thread) {
	struct chachathread *localthread = (struct chachathread *)thread;
	fprintf(stderr, "Made thread!\n");
	if (!EVP_CipherInit(localthread->ctx->main_evp, NULL, NULL, localthread->seqbuf, 1)) {
		localthread->response = SSH_ERR_LIBCRYPTO_ERROR;
		return 0;
	}
	if (EVP_Cipher(localthread->ctx->main_evp, localthread->dest + localthread->aadlen, localthread->src + localthread->aadlen, localthread->len) < 0) {
		localthread->response = SSH_ERR_LIBCRYPTO_ERROR;
		return 0;
	}
	return 0;
}

struct chachapoly_ctx *
chachapoly_new(const u_char *key, u_int keylen)
{
	struct chachapoly_ctx *ctx;

	if (keylen != (32 + 32)) /* 2 x 256 bit keys */
		return NULL;
	if ((ctx = calloc(1, sizeof(*ctx))) == NULL)
		return NULL;
	if ((ctx->main_evp = EVP_CIPHER_CTX_new()) == NULL ||
	    (ctx->header_evp = EVP_CIPHER_CTX_new()) == NULL)
		goto fail;
	if (!EVP_CipherInit(ctx->main_evp, EVP_chacha20(), key, NULL, 1))
		goto fail;
	if (!EVP_CipherInit(ctx->header_evp, EVP_chacha20(), key + 32, NULL, 1))
		goto fail;
	if (EVP_CIPHER_CTX_iv_length(ctx->header_evp) != 16)
		goto fail;
	return ctx;
 fail:
	chachapoly_free(ctx);
	return NULL;
}

void
chachapoly_free(struct chachapoly_ctx *cpctx)
{
	if (cpctx == NULL)
		return;
	EVP_CIPHER_CTX_free(cpctx->main_evp);
	EVP_CIPHER_CTX_free(cpctx->header_evp);
	freezero(cpctx, sizeof(*cpctx));
}

/*
 * chachapoly_crypt() operates as following:
 * En/decrypt with header key 'aadlen' bytes from 'src', storing result
 * to 'dest'. The ciphertext here is treated as additional authenticated
 * data for MAC calculation.
 * En/decrypt 'len' bytes at offset 'aadlen' from 'src' to 'dest'. Use
 * POLY1305_TAGLEN bytes at offset 'len'+'aadlen' as the authentication
 * tag. This tag is written on encryption and verified on decryption.
 */
int
chachapoly_crypt(struct chachapoly_ctx *ctx, u_int seqnr, u_char *dest,
    const u_char *src, u_int len, u_int aadlen, u_int authlen, int do_encrypt)
{
	u_char seqbuf[16]; /* layout: u64 counter || u64 seqno */
	int r = SSH_ERR_INTERNAL_ERROR;
	u_char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];
	struct chachathread thread[4];
	pthread_t threadlist[10];
	
	/*
	 * Run ChaCha20 once to generate the Poly1305 key. The IV is the
	 * packet sequence number.
	 */
	memset(seqbuf, 0, sizeof(seqbuf));
	POKE_U64(seqbuf + 8, seqnr);
	memset(poly_key, 0, sizeof(poly_key));
	if (!EVP_CipherInit(ctx->main_evp, NULL, NULL, seqbuf, 1) ||
	    EVP_Cipher(ctx->main_evp, poly_key,
	    poly_key, sizeof(poly_key)) < 0) {
		r = SSH_ERR_LIBCRYPTO_ERROR;
		goto out;
	}

	/* If decrypting, check tag before anything else */
	if (!do_encrypt) {
		const u_char *tag = src + aadlen + len;

		poly1305_auth(expected_tag, src, aadlen + len, poly_key);
		if (timingsafe_bcmp(expected_tag, tag, POLY1305_TAGLEN) != 0) {
			r = SSH_ERR_MAC_INVALID;
			goto out;
		}
	}

	/* Crypt additional data */
	if (aadlen) {
	  if (!EVP_CipherInit(ctx->header_evp, NULL, NULL, seqbuf, 1) ||
		    EVP_Cipher(ctx->header_evp, dest, src, aadlen) < 0) {
			r = SSH_ERR_LIBCRYPTO_ERROR;
			goto out;
		}
	}

	//fprintf(stderr, "1: len = %d, aadlen = %d seqnr= %d\n", len, aadlen, seqnr);
	
	// max len is 32k. first pass break any len > 8192 into
	// chunks and submit each chunk to a new thread.
	// the difficult part is determining the block number.
	// blocks seem to be 64 bytes (512 bits). So if we move
	// 8192 bytes into the keystream we should have to increase the block
	// counter by 128 (8192/64) so seqnum1 = 1, seqnum2=129, seqnum3 = 257,
	// seqnum4 = 385. The right way to determine the correct block counter is
	// to take the pointer position divide by 64 and add 1. 

	// the next chunk of code is where all the magic happens in terms of the crypto
	// cipher init sets things up at the specific block counter
	// EVP_Cipher actually runs the code.
	// so I'll need to create struct to hold the arguments being passed
	// and put these lines of code in a threadfunction I can call

/* struct chachathread { */
/* 	u_char *dest; */
/* 	u_char *src; */
/* 	u_int len; */
/* 	u_int aadlen; */
/* 	u_char *seqbuf; */
/* 	struct chachapoly_ctx *ctx; */
/* } chachathread; */

	u_int chunk = 8192;
	u_int bufptr = 0;
	int i = 0;
	int k = 0;
	char *dstblk[4];
	char *srcblk[4];
	int tmpaadlen =0;
	//foo
	if (len > chunk) {
	/* 	if (aadlen > 0) */
	/* 		tmpaadlen = aadlen; */
	/* 	while (bufptr < len) { */
	/* 		if ((len - bufptr) > chunk) { */
	/* 			srcblk[i] = calloc(chunk, sizeof(char)); */
	/* 			memcpy(srcblk[i], src+bufptr, chunk); */
	/* 			dstblk[i] = calloc(chunk, sizeof(char)); */
	/* 			bufptr += chunk; */
	/* 			fprintf(stderr, "bufptr is %d of %d\n", bufptr, len); */
	/* 			tmpaadlen = 0; */
	/* 		} else { */
	/* 			srcblk[i] = calloc((len-bufptr), sizeof(char)); */
	/* 			memcpy(srcblk[i], src+bufptr, (len-bufptr)); */
	/* 			dstblk[i] = calloc((len-bufptr), sizeof(char)); */
	/* 			bufptr = len; */
	/* 			fprintf(stderr,"bufptr is %d of %d\n", bufptr, len); */
	/* 		} */
	/* 		i++; */
	/* 	} */
	/* 	k = i; */
	/* 	for (i = 0; i < k; i++) { */
			/* Set Chacha's block counter to 1 */
			seqbuf[0] = 1;
			// fill the struct for the thread
			//thread[i].dest = dstblk[i];
			//thread[i].src = srcblk[i];
			thread[i].dest = &dest;
			thread[i].src = &src;
			//fprintf(stderr,"i:%d  %s\n", i, srcblk[i]);
			thread[i].len = len;
			thread[i].aadlen = aadlen;
			thread[i].seqbuf = seqbuf;
			thread[i].ctx = ctx;
			thread[i].response = 0;
			fprintf (stderr, "creating thread %d\n", i);
			pthread_create(&threadlist[i], NULL, chachapoly_thread_work, (void *)&thread[i]);
		/* } */
		/* for (i = 0; i < k; i++) { */
		/* 	fprintf(stderr, "killing thread %d of %d", i, k); */
		pthread_join(threadlist[i], NULL);
		/* } */
		/* int tmplen = 0; */
		/* int dstptr = 0; */
		/* for (i=0; i < k; i++) { */
		/* 	if (thread[i].response == SSH_ERR_LIBCRYPTO_ERROR) { */
		/* 		fprintf(stderr,"Whoops!\n"); */
		/* 		goto out; */
		/* 	} */
		/* 	tmplen = strlen(thread[i].dest); */
		/* 	memcpy(dest+aadlen+dstptr, thread[i].dest, tmplen); */
		/* 	dstptr += tmplen; */
		/* 	fprintf(stderr, "%s\n", dest); */
		/* } */
	} else {
		/* Set Chacha's block counter to 1 */
		seqbuf[0] = 1;
		if (!EVP_CipherInit(ctx->main_evp, NULL, NULL, seqbuf, 1) ||
		    EVP_Cipher(ctx->main_evp, dest + aadlen, src + aadlen, len) < 0) {
			r = SSH_ERR_LIBCRYPTO_ERROR;
			goto out;
		}
	}
	
	/* If encrypting, calculate and append tag */
	if (do_encrypt) {
		poly1305_auth(dest + aadlen + len, dest, aadlen + len,
		    poly_key);
	}
	r = 0;
 out:
	explicit_bzero(expected_tag, sizeof(expected_tag));
	explicit_bzero(seqbuf, sizeof(seqbuf));
	explicit_bzero(poly_key, sizeof(poly_key));
	return r;
}

/* Decrypt and extract the encrypted packet length */
int
chachapoly_get_length(struct chachapoly_ctx *ctx,
    u_int *plenp, u_int seqnr, const u_char *cp, u_int len)
{
	u_char buf[4], seqbuf[16];

	if (len < 4)
		return SSH_ERR_MESSAGE_INCOMPLETE;
	memset(seqbuf, 0, sizeof(seqbuf));
	POKE_U64(seqbuf + 8, seqnr);
	if (!EVP_CipherInit(ctx->header_evp, NULL, NULL, seqbuf, 0))
		return SSH_ERR_LIBCRYPTO_ERROR;
	if (EVP_Cipher(ctx->header_evp, buf, (u_char *)cp, sizeof(buf)) < 0)
		return SSH_ERR_LIBCRYPTO_ERROR;
	*plenp = PEEK_U32(buf);
	return 0;
}
#endif /* defined(HAVE_EVP_CHACHA20) && !defined(HAVE_BROKEN_CHACHA20) */
